'use strict';

import Core from '../tools/core.js';
import Evented from "../components/evented.js";
import ChunkReader from "../components/chunkReader.js";
import SimulationDEVS from "../simulation/simulationDEVS.js";
import SimulationCA from "../simulation/simulationCA.js";
import SimulationIRR from "../simulation/simulationIRR.js";
import Model from "../simulation/model.js";

export default class CadmiumCell extends Evented { 

	ReadByChunk(file, delegate) {		
		return ChunkReader.ReadByChunk(file, "\n", (parsed, chunk, progress) => {
			if (!parsed) parsed = [];
		
			parsed = delegate(parsed, chunk);
			
			this.Emit("Progress", { progress: progress });
			
			return parsed;
		});
	}
	
	ReadLog(file) {
		return ChunkReader.ReadByChunk(file, "\n", (parsed, chunk, progress) => {
			if (parsed == null) parsed = [];
			
			parsed = this.ParseLogChunk(parsed, chunk);
			
			this.Emit("Progress", { progress: progress });
			
			return parsed;
		});
	}
	
	Parse(files) {
		var d = Core.Defer();
		
		var cfg = files.find(function(f) { return f.name.match(/scenario.json/i); });
		var log = files.find(function(f) { return f.name.match(/messages.txt/i); });
		var style = files.find(function(f) { return f.name.match(/style.json/i); });

		if (!cfg || !log) {
			d.Reject(new Error("A config (.json) and a log (.txt) file must be provided for the Cadmium Cell-DEVS parser."));
		
			return d.promise;
		}
					
		ChunkReader.Read(cfg, this.ParseStructure.bind(this)).then(response => {
			this.structure = response;
			
			this.t = "0";
			
			var p1 = this.ReadLog(log);
			var p2 = ChunkReader.Read(style, (content) => JSON.parse(content));

			Promise.all([p1, p2]).then((data) => {			
				if (!data[0]) return d.Reject(new Error("Unable to parse the messages (.log) file."));
				
				var simulation = SimulationCA.FromJson(this.structure, data[0]);
				
				d.Resolve({ simulation:simulation, style:data[1] || null });
			}, (error) => d.Reject(error));
		});
		
		return d.promise;
	}
	
	ParseStructure(file) {
		var json = JSON.parse(file);
		
		var size = json.scenario.shape;
		
		if (size.length == 2) size[2] = 1;
		
		var info = { name:json.scenario.default_cell_type, simulator:"Cadmium", type:"Cell-DEVS" }
		var model = { name:info.name, type:"coupled", ports:[], links:[], size:size }
		var ports = [];
		
		for (var name in json.scenario.default_state) {
			var p = { model:model.name, name:name, type:"output" };
			
			model.ports.push(p);
			ports.push(p);
		}
		
		model.template = ports.map(p => p.name);
		
		return { ports:ports, info:info, models:[model], size:size }
	}
			
	ParseLogChunk(parsed, chunk) {		
		var start = 0;		
		
		while (start < chunk.length) {				
			var end = chunk.indexOf('\n', start);
			
			if (end == -1) end = chunk.length + 1;
			
			var line = chunk.substr(start, end - start);
			
			if (line.startsWith("[")) {
				// parse coord 
				var i = line.indexOf("(") + 1;
				var j = line.indexOf(")", i);
				var c = line.substr(i, j - i).split(',');
				
				// parse values
				var i = line.indexOf("<", j) + 1;
				var j = line.indexOf(">", i);
				var values = line.substr(i, j - i).split(',');
			
				// parse model name
				var patt = "generated by model ";
				var i = line.indexOf(patt, j) + patt.length;
				var j = line.indexOf("_(", i);
				var m = line.substr(i, j - i);
				
				for (var i = 0; i < values.length; i++) {
					var p = this.structure.ports[i];
					var v = {}
					
					v[p.name] = +values[i];

					if (c.length == 2) c[2] = 0;

					parsed.push({ time:this.t, cell:c, value:v });
				}
			}
			else this.t = line;
			
			var start = start + line.length + 1;
		};
		
		return parsed;
	}
}